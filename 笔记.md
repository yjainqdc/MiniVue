#  整体概念

### vue框架设计中的整体概念

1. 命令式
2. 声明式
3. 心智负担（开发体验如何）
4. 框架设计与取舍
5. 运行时和编译时
6. 副作用（setter、getter）
7. reactivity、runtime、compiler
8. ts良好支持

### sourceMap

用来添加debugger，用于调试，映射ts代码位置

# 开始

### 创建项目

首先创建了一个项目，然后npm init 初始化项目，生成packages.json

创建几个文件夹如下，分别对应几个模块

![1678283878421](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678283878421.png)

### 配置TS

>  TS 是一种可以对类型进行约束的工具 
>
> [上手](https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html)

首先npm i ts....安装一下

然后tsc -init生成一个tsconfig.json文件

在上述文件中进行ts配置

### 代码格式

不适用原来vue中的eslintrc和prettierrc，我们只使用prettier做代码格式化

![1678326384121](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678326384121.png)

1.插件安装

2.建立.prettierrc文件进行格式化配置，比如去不去掉分号，字符串统一单引号等等

如：

```js
{
    //是否去掉句末分号
    "semi": false,
     //字符串统一单引号
    "singleQuote": true,
     //80个字符一换行
    "printWidth": 80,
     //跟随逗号
    "trailingComma":"none",
     //箭头函数单参数去括号
    "arrowParens": "avoid"

}
```

### 模块打包器

rollup.js是打包器

webpack太大了，用小而美的

需要配置文件rollup.congig.js

 默认导出一个数组，数组的每一个对象都是一个单独的导出文件配置，详细可查：https://www.rollupjs.com/guide/big-list-of-options

配置入口和出口文件：

```js
    {
        //配置入口文件,整个项目的入口文件
        input:'package/vue/src/index.ts',
        //打包出口
        output:[
            //导出iife模式的包
            {
                //开启soucemap
                sourcemap:true,
                //导出文件地址
                file:'./packages/vue/dist/vue.js',
                //生成包格式
                format:'iife',
                //变量名（就是我导入的时候一般用啥，比如Vue）
                name:'MiniVue'

            }
        ],
        //插件
        plugins:
    },
```

配置插件

首先npm i安装一下

然后安装完成后packages.json生成了

![1678329319835](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678329319835.png)

```js
//然后配置在rollup配置文件
        //插件
        plugins:[
            //ts
            typescript({
                sourceMap:true
            }),
            //模块导入的路径补全
            resolve(),
            //转commonjs为ESM
            commonjs()
        ]
```

然后packagejson中配置好build："build":"rollup -c",

但是还缺个插件npm i --save-dev tslib@2.4.0

然后我打包了npm run build

> 有个小错误，一点过要细心
>
> ![1678333158392](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678333158392.png)
>
> 路径写错了，导致一直有个小问题浪费一些时间
>
> (plugin rpt2) Error: Could not resolve entry module (package/vue/src/index.ts).

### 路径映射

在tsconfig.json中设置快捷导入

![1678333947129](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678333947129.png)

# 响应系统

## reactive和effect

### 前言

影响视图变化得数据成为响应数据。

**先解释一下js的程序性**：固定的不会发生变化的执行流程

响应性则是发生响应的改变，老生常谈，过！

**vue2和vue3的响应**：略

proxy原理：创建一个对象的代理，从而实现基本操作。（只有代理对象会触发setter、getter）

![1678334979044](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678334979044.png)

 **Reflect对象**：

一个内置对象，提供了拦截js的方法，包括get、set等

![1678335664308](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678335664308.png)

第三个参数可以改变this指向

例子![1678335957413](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678335957413.png)

### 调试vue3源码

设置好sourceMap之后，我们使用断点调试，查看reactuvuty/src/reactive.ts中的内容

#### 查看reactive函数如何实现

![1678520374321](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678520374321.png)

![1678520440228](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678520440228.png)

return了一个proxy对象

可以看到其中涉及到了targetType，我们去看一下这是什么（枚举对象，TS中特有的）

![1678520611657](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678520611657.png)

所以在new proxy 时，出发了baseHandlers这个东西

#### baseHandlers是什么

baseHandlers是reactive函数调用createReactiveObject函数时传入的第三个参数，也就是它mutableHandlers

![1678521098317](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678521098317.png)

我们去看看这是什么

这是定义在reactuvuty/src/baseHandlers.ts中的函数

![1678521167749](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678521167749.png)

其中，get、set均为定义好的监视数据变化的回调函数

![1678521239208](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678521239208.png)

总结：reactive 就是返回了一个vue自己封装好的proxy

#### effect方法

![1678525621437](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678525621437.png)

effect函数被定义在reactuvuty/src/effect.ts中

首先我们找到这个函数

![1678525816136](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678525816136.png)

可以看到，其中有个Reactiveffect类，去见识一下是啥

![1678525990002](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678525990002.png)

这个类还有一个run方法和一个stop方法

然后再经过这个类的构造之后得到了一个_effect实例，其中的fn就是html中effect()内部的语句(匿名函数)

再往下说进行，到了_effect.run()，看看具体怎么执行的

![1678526526563](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678526526563.png)

我们执行document.querySelector('#app').innerText = obj.name，成功进入了createGetter

![1678527261395](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678527261395.png)

#### 看一下track，比较重要，收集执行依赖

![1678527746839](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678527746839.png)

其中creatDep可以看出，Dep本质是Set

![1678527539645](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678527539645.png)

最后执行了trackEffects(dep, eventInfo)

![1678529310156](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678529310156.png)

此时，targetMap是这样的
![1678530337105](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678530337105.png)

指定对象的指定属性找到对应的effect，这就完成了依赖收集

effect主要做了三件事：

![1678530538938](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678530538938.png)

#### setter

稍后补充

### Weakmap和Map的区别

曾经整理过，Map同Object区别是Map的key可以是任意形式的。

Weakmap主要区别是，key必须为object，引用形式为弱引用（不影响垃圾回收，就相当于没有引用就完了）。

### *首先手写reactive函数框架

```js
//packages/reactivity/src/reactive.ts

import { mutableHandlers } from "./baseHandlers"

export const reactiveMap = new WeakMap<object,any>()


//对外暴漏的reactiveAPI
export function reactive(target:object){
    return createReactiveObject(target,mutableHandlers,reactiveMap)
}


//创建代理对象的函数
function createReactiveObject(
    target:object,
    baseHandlers:ProxyHandler<any>, //proxy接口ProxyHandler
    proxyMap:WeakMap<object,any>
){
    //缓存机制
    const existingProxy = proxyMap.get(target) 
    if(existingProxy){
        return //如果已经有了，那就直接返回就很高了
    }
    //如果没有就创建
    const proxy = new Proxy(target,baseHandlers)
    //然后维护一下缓存
    proxyMap.set(target,proxy)
    return proxy
}
```

然后我们需要导出这个函数，逻辑是这样的

先在index中获取reactive并导出

![1678586053301](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678586053301.png)

然后我在vue中在获取并导出

![1678586102042](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678586102042.png)

为什么可以这么导入，因为我在ts.config中设置过了

![1678586148112](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678586148112.png)

然后就可以build一下，看一下生成的vue.js

![1678586189273](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678586189273.png)

可以对比一下和ts的区别，然后使用的话，我只要引入使用就可以了。

![1678586250309](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678586250309.png)

### *写一下监视操作+收集触发依赖

首先是在baseHandler.ts中

```js
import { track, trigger } from "./effect"

const get = createGetter()
const set = createSetter()

//getter
function createGetter(){
    return function get(target:object,key:string|symbol,receiver:object){
        const res = Reflect.get(target,key,receiver)
        //依赖收集，在effect.ts
        track(target,key)
        return res
    }
}

//setter
function createSetter(){
    return function get(target:object,key:string|symbol,value:unknown,receiver:object){
        const res = Reflect.set(target,key,value,receiver) // 得到了布尔值
        //触发依赖，在effect.ts
        trigger(target,key,value)
        return res
    }
}

//监视操作
export const mutableHandlers: ProxyHandler<object> = {
    get,
    set
}

```

然后其中track和trigger函数来自effect.ts

```js
//收集依赖
export function track(target:object,key:string|symbol){
    console.log('收集依赖')
}

//触发依赖
export function trigger(target:object,key:string|symbol,value:unknown){
    console.log('触发依赖')
}
```

下面看下效果

我设置了定时器，2s修改obj属性，这个obj已经被reactive了

![1678588303960](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678588303960.png)

### rollup热更新

每次都npm run build太麻烦了，不如直接搞热更新，自动监测文件变化生成vue.js

package.json加行配置就成了

![1678588866788](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678588866788.png)

![1678588896961](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678588896961.png)

###  *effect编写

effect 会立即执行传入的函数，并在函数的依赖发生变化时重新运行该函数（后文统一称为依赖函数） 

我们这里编写的effect的作用就是首先封装成一个包含当前依赖的类，然后立即执行effect中的执行语句（第一次触发），具体收集和再次触发这些依赖在track和trigger中

如下：

```js
//对外暴漏的effectAPI，依赖
//======================================================================
//effect 会立即执行传入的函数，并在函数的依赖发生变化时重新运行该函数(依赖函数)
export function effect<T=any>(fn:()=>T){
    //构建ReactiveEffect实例
    const _effect = new ReactiveEffect(fn)

    _effect.run()
}

//一个公共标记，保存当前被执行的effect
export let activeEffect: ReactiveEffect|undefined

 //这个类用于方便存依赖
export class ReactiveEffect<T=any>{
    constructor(public fn:()=>T){

    }
    run(){
        //标记当前被执行的effect
        activeEffect = this
        return this.fn()
    }
}
//======================================================================
```

然后同reactive一样，暴漏出去

![1678593372905](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678593372905.png)

导入然后使用，当然，现在只能暂时执行一次，当发生改变时我们需要再次执行才对，那就是下边的工作。

### *targetMap收集依赖（track）

![1678593613346](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678593613346.png)

 我们需要给不同对象的不同属性绑定好一个依赖，然后这需要我们创建一个weakMap

结构大概长这样，起名叫targetMap：

![1678595675760](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678595675760.png)

首先我们需要创建一下

![1678599363810](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678599363810.png)

然后我们在track中维护一下

![1678599449019](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678599449019.png)

然后我们结合effect看，effect执行时，第一次执行会标记当前被执行的effect： activeEffect = this

这样activeEffect就有值了，然后因为effect会立刻执行一遍嘛，所以也就会触发get方法，所以就到了track，此时activeEffect中存放的就是当前key的依赖，在track中，我们们绑定当前target的键值对，没有的话就创建个新的，再按照key存放响应的fn(activeEffect)就可以了

我们输出一下target，看一下案例：

### ![1678599896769](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678599896769.png)*targetMap触发依赖（trigger）

已经绑定好了，下一个需求是每次修改都要触发effect里边的内容

没啥好说的，直接上trigger写法就完事了

![1678600633974](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678600633974.png)

当set时触发了trigger

看一下案例：

![1678600684582](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678600684582.png)

分析一下，首先一上来obj为“张三”，然后执行一次effect，有读取obj.name行为，渲染到dom上，此时执行一次track。然后定时器两秒之后修改，执行一次trigger，然后渲染到页面，这里面有读取obj.name行为，然后再track一下，渲染到页面上。

因为我在track里打印了一下targetMap，所以会打印两次：

![1678600909645](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678600909645.png)

### 当前存在问题：只能执行一个effect

如果我搞了两个effect

![1678602775415](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678602775415.png)

则会出现这种情况

![1678602799731](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678602799731.png)

只变一个

所以我们需要整个一对多的

![1678601217423](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678601217423.png)

### *Dep依赖数组的维护，实现一对多

回顾一下，之前我们存依赖是直接将key对应的依赖使用set替换掉：depsMap.set(key,activeEffect)

这不行，我们需要搞一个依赖的容器，用Set比较合适，我们单独再reactivity中创建一个dep.ts干这个事：

![1678603096786](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678603096786.png)

同时，我们需要修改一下track和trigger中的依赖收集和触发步骤

首先得改一下targetMap的数据结构定义：

![1678603214289](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678603214289.png)

track中：

![1678603328823](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678603328823.png)

trigger中：

![1678603441624](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678603441624.png)

### 当前reactive存在的问题

1.不能对简单数据类型进行绑定（使用ref）

2.解构之后失去响应性，也就是const {name} = obj，此时name变量不再有响应性

下文预告：

![1678603780985](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678603780985.png)



## ref

### 调试ref源码

![1678966077472](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678966077472.png)

进入了一个creatRef函数

![1678966133769](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678966133769.png)

然后new 了一个新类别RefImpl，其实这个就很熟悉了，就是ref之后的返回类型

看看里边怎么处理的

![1678966441698](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678966441698.png)

其中toReactive函数：

![1678966485257](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1678966485257.png)

其中value被set和get关键字修饰，分别在get和set时被触发

再接下来的时候effect已经被执行完成了，同上个部分一样，然后effect中触发getter，于是出发了上面代码中get value中的trackRefValue

【有值得注意的一点，RefImpl中已经有Dep这个属性了】

### 源码中依赖的收集和触发

稍后补充

### *ref函数的实现

在activatity中的ref.ts中

```js
export interface Ref<T=any>{
    value:T
}

export function ref(value?:unknown){
    //shaow设置为false，都会取走toreactive中isObject的校验
    return createRef(value,false)

}

function createRef(rawValue:unknown,shallow:boolean){
    //首先判断，如果是ref的数据，直接返回就行了
    if(isRef(rawValue)){
        return rawValue
    }
    //新建一个和ref专属类别
    return new refImpl(rawValue,shallow)
}

//判断是否为refimpl类型
// r is Ref,Ref是接口
function isRef(r:any):r is Ref{
    //双感叹号强转成布尔值,首先判断了是否为Ref型数据
    return !!(r && r.__v_isRef)
}

class refImpl<T>{
    private _value:T
    private _rawValue:T
    //dep是Dep，默认是undefined
    public dep?: Dep=undefined
    public readonly __v_isRef = true

    constructor(value:T,public readonly __v_isShallow:boolean){
        this._rawValue = value
        //如果不是普通数据类型，ref的value就转成reactive包裹一下
        this._value = this.__v_isShallow ? value : toReactive(value)
    }

    //用get和set修饰，顾名思义，就会再获取 obj.value 执行get，在修改执行set
    //本质上ref使用的是get和set的主动触发value函数
    //***********get value ***********/
    get value(){
        //添加ref类型的依赖
        trackRefVal(this)
        return this._value
    }
    //***********set value ***********/
    set value(newValue){
        if(hasChanged(newValue,this._rawValue)){
            //如果发生了改变
            this._rawValue = newValue
            this._value = toReactive(newValue)
            //toReactive中会判断是不是对象的，如果不是就返回value
            triggerRefVal(this)
        }
    }
}

```

值得注意的一点，toReactive中会进行判断，是否是对象，如果是对象，就将其reactive一下，不然就直接返回原本的value值

在reactive中写了toReactive函数：

```js
// ref中的toReactive
//======================================================================
//泛型，返回值为T
export const toReactive = <T extends unknown>(value:T):T=>{
    //isObject定义再index
    return isObject(value)?reactive(value as object):value
}
//======================================================================
```

另外，在index.ts中，存在一些公用函数

![1679107929231](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679107929231.png)

### *ref中依赖的收集和触发

```js
//============================================================
// 收集依赖
export function trackRefVal(ref){
    //activeEffect是个公共的标记，判断当前的activeEffect是否存在
    //流程：effec中创教你新的ReactiveEffect实例=>构造函数时，令activeEffec=this=>effect.run=>触发get
    if(activeEffect){
        //没有依赖就创建依赖
        //trackEffectsn帮忙实现添加依赖
        trackEffects(ref.dep || (ref.dep = createDep()))

    }
}

//============================================================
//触发依赖
export function triggerRefVal(ref){
    if(ref.dep)triggerEffects(ref.dep)
}

```

ref中的dep存在RefImpl这个类的dep属性中

其实如果是object函数，它的结构是这样的：

一个RefImpl实例中的value属性包裹了一个proxy

### *ref的响应式原理

本质上并没有对属性进行监听，只是利用get和set修饰了value方法，主动触发value函数实现数据的改变和依赖收集。

所以说必须通过.value来访问保证响应性。

## compute

### compute粗略原理

首先是一个computeRefImpl类，类似ref，传入的函数参数作为effect的fn

回看再补充

![1679127251315](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679127251315.png)



### *computed流程实现

先捋一下代码流程

首先我在测试用例中写了一个computed

![1679141297195](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679141297195.png)

会这么干

![1679141406537](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679141406537.png)

我们将computed的回调传进来，使用getter接受，然后去新建一个类

![1679141584186](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679141584186.png)

首先我们传入了一个schedler给ReactiveEffect类，所以我们也修改了ReactiveEffect类的构造

![1679141803679](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679141803679.png)

在下边，如果读取的话就执行get value，这个没有什么异议

![1679142455311](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679142455311.png)

这里面有一个特别重要的：

![1679143986251](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679143986251.png)

然后我去触发

因为每一个我用到的属性里都加了当前的这个ReactiveEffect作为dep，当他们set时，会很顺利地执行scheduler

![1679144121645](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679144121645.png)

![1679144166969](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679144166969.png)

如果computed中有调度器，我们需要执行调度器，有调度器地effect都是计算属性的计算逻辑

举个例子：

![1679144248965](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679144248965.png)

1.执行computed时，ComputedRefImpl类的构造函数给它造了ReactiveEffect实例，然后run了一下，让activeEffect指向了this，然后触发到obj.name的get，就顺便给他绑定了dep

2.这时候obj的name再改变的时候，很顺利的出发了这个依赖，同时这个依赖中有scheduler，顺便就把dirty搞成true了，然后再到ComputedRefImpl实例中触发它的依赖（也就是a的）

3.因为此时dirty已经为true，再执行包含a的effect时，执行了get，因为dirty为true，所以再次出发了effect的run，然后再走了第一遍的流程，但是已经存在依赖了，会不会重复绑定？会，就是又重新绑定了一下，看下图我做了实验。当然，绑定两次也没用，因为Dep是个Map。

![1679145990330](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679145990330.png)

4.这样就更新了视图

### *计算属性的缓存逻辑

目前的逻辑还是有些问题

![1679147220160](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679147220160.png)

思考一下，这样写会产生什么问题，计算逻辑作为effect存储到dep

然后我们修改一下obj.name，就会出现死循环

其主要原因是，连着两次get计算属性，第一次effect.run使activeEffect变成了计算逻辑，于是第二次get计算属性就把自己的计算逻辑放到了自己的dep里

![1679194912271](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679194912271.png)

然后这样会产生循环：

1.非计算effect触发computeRefImpl的get，然后dirty变为false

2.再到计算属性的effect，dirty变为true，并且trigger

3.trigger中触发computeRefImpl的dep，其中包括计算和非计算两个依赖

4.于是开始套娃循环

解决方法：

![1679195842998](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679195842998.png)

我们先执行计算属性的effect，再执行非计算属性的，这样就合理了。

但是想一个问题，这样的话，不会计算属性effect这个地方，一直死循环吗？

答案是不会，因为我们第一次执行scheduler时dirty已经为true，第二次就不会再执行其中的triggerRefValue了。

![1679195482628](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679195482628.png)

![1679195899625](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679195899625.png)

修改后

![1679195940558](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679195940558.png)

手画逻辑：

![1679196251355](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679196251355.png)

### 计算属性的一些重点

![1679196043995](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679196043995.png)

## watch 

![1679225185651](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679225185651.png)

### scheduler的作用

调整执行顺序

控制执行规则（比如使用队列）

**见下文**

### *effect的懒执行

暂时不重要

![1679228903506](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679228903506.png)

### *watch基本逻辑实现

本质还是reactiveEffect

大概思路：把我们的回调作为ReactiveEffect，执行一次run，激活activeEffect，然后手动去遍历一遍source，触发他们的get，都给绑定上，然后利用scheduler来执行回调。值得一提的是，这些回调被封装在job函数中，然后job外边又包了一层promise，保证watch的回调都是异步的。

另外，还需要注意的一点就是newValue和oldValue的转换，oldValue一直存储在dowatch中，然后执行一次就会新旧交替一下。

以下是详细代码带批注：runtime-core/src/apiWatch.ts

```js
import { hasChanged, isObject } from "@vue/reactivity"
import { EMPTY_OBJ } from "@vue/shared"
import { ReactiveEffect } from "packages/reactivity/src/effect"
import { isReactive } from "packages/reactivity/src/reactive"
import { queuePreFlushCb } from "./scheduler"

//监视属性配置类型接口
export interface WatchOptions<immediate = boolean>{
    immediate?:immediate
    deep?:boolean
}

//外部入口函数
export function watch(source,cb:Function,options?:WatchOptions){
    return doWatch(source,cb,options)
}

//watch在这里实现
function doWatch(source,cb:Function,{immediate,deep}:WatchOptions = EMPTY_OBJ){
    let getter:()=>any

    //source是监听的源
    if(isReactive(source)){
        getter = ()=>source
        //如果是reactive类型，肯定自动deep
        deep = true
    }else{
        getter = ()=>{}
    }

    //======在此进行依赖收集=======//
    if(cb&&deep){
        //本质：遍历所有source，完成依赖触发
        const baseGetter = getter
        //等同于传进去了source 
        getter = ()=>traverse(baseGetter())
    }

    //======在此存储oldvalue值=======//
    let oldValue = {}

    //======这里就是包装好的cb=======//
    //job每次执行相当于cb执行一次
    const job = ()=>{
        if(cb){
            const newValue = effect.run()
            if (deep||hasChanged(newValue,oldValue)){
                cb(newValue,oldValue)
                //新值变旧值存起来
                oldValue = newValue
            }
        }
    }

    //======在此定义调度器，变为异步=======//
    //作用就在这里，把这些job变为异步的
    let scheduler = ()=>queuePreFlushCb(job)

    //======在此定义effect，借助scheduler实现监视回调=======//
    const effect = new ReactiveEffect(getter,scheduler)

    //======在此执行effect.run，绑定上activeEffect，当然回调啥时候执行另说=======//
    if(cb){
        if(immediate){
            //立刻触发回调
            job()
        }else{
            //不然就拿到旧值就行了，本质这个run的fn就是上面的getter
            //此处直接新值变旧值
            oldValue = effect.run()
        }
    }else{
        //没有回调的话直接就run，作用是activeEffect为此
        effect.run()
    }

    return ()=>{
        effect.stop()
    }
}

export function traverse(value:unknown){
    if(!isObject(value)){
        return value
    }
    //如果是对象，就递归去遍历一下
    for (const key in value as object){
        //递归地去触发get
        traverse((value as object)[key])
    }
    return value
}
```

其中queuePreFlushCb作用是实现调度系统，控制执行顺序【暂时先理解为套一层promise，然后搞成队列一点点执行，后续有其他作用再补充】

```js

//在这里实现整个的调度队列
let  isFlusshPending = false

const resolvedPromise = Promise.resolve()

let currentFlushPromise:Promise<void> | null = null

//执行队列
const pendingPreFlushCbs:Function[] = []

//外部入口函数
export function queuePreFlushCb(cb:Function){
    queueCb(cb,pendingPreFlushCbs)
}

//推入执行队列
function queueCb(cb:Function,pendingQueue:Function[]){
    pendingQueue.push(cb)
    queueFlush()
}

//依次执行队列中的执行函数（套一层promise变异步）
function queueFlush(){

    if(!isFlusshPending){
        isFlusshPending = true
        currentFlushPromise = resolvedPromise.then(flushJobs)
    }
}

//处理队列
function flushJobs(){
    isFlusshPending = false //执行开始了，不再等待了，就把状态改过来
    flushPreFlushCbs()
}

function flushPreFlushCbs(){
    if(pendingPreFlushCbs.length){
        //拷贝去重
        let activePreFlushCbs = [...new Set(pendingPreFlushCbs)]
        //原数组直接置空了
        pendingPreFlushCbs.length = 0

        for (let i = 0;i<activePreFlushCbs.length;i++){
            //这么一页代码，最有用就在这里，搞了一堆，就是套了个promise，然后搞个队列执行
            activePreFlushCbs[i]()
        }
    } 
    
}
```

你看，写了一堆代码，有用的其实就是搞个队列存存promise包装好的函数，再去去重

## 响应式的原理草图

![1679230564442](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679230564442.png)



# 运行时

## 基本原则和概念

### DOM树

HTML DOM节点树

虚拟DOM树

![1679231405198](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679231405198.png)

### 节点操作

挂载节点

![1679231878459](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679231878459.png)

然后是更新节点的操作（先unmount）

![1679232533618](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679232533618.png)

### 啥是h函数、render

![1679275513918](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679275513918.png)

得到一个vnode对象

![1679275552714](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679275552714.png)

使用方式（参数除了type，均为可选）【官网有】

![1679275635761](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679275635761.png)

h生成vnode，render将vnode生成真实节点

### 设计原则

为什么代码分成runtime-core和runtime-dom

runtime-core放置渲染核心逻辑

runtime-dom操作dom

## h函数构建

### 大体思路

![1679276253000](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679276253000.png)

h触发creatVnode，creatVnode赋值flag变量确定类型，触发creatBaseVnode



### *h函数实现

我们需要有一个虚拟节点的统一标准 VNode，方便render

![1679308942476](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679308942476.png)

首先我们构建整体函数h，主要是一个参数处理，比如传两个参数或者传3个参数等等：

```js
//在这里主要对参数进行了一个处理
export function h(type:any,propsOrChildren?:any,children?:any):VNode{
    //首先获取参数长度
    const l = arguments.length

    //如果参数长度为2
    if(l == 2){
        if(isObject(propsOrChildren)&&!Array.isArray(propsOrChildren)){
            if(isVNode(propsOrChildren)){
                //1.如果第二个参数是对象且为VNode，当成children来用
                return createVNode(type,null,[propsOrChildren])
            }
            //2.如果第二个参数是对象，不为VNode，当成props来用
            return createVNode(type,propsOrChildren)
        }else{
            //3.如果第二个参数是数组或字符串，当成children数组来用
            return createVNode(type,null,propsOrChildren)
        }
    }else{
        //如果参数长度大于3
        if(l>3){
            //此情况为一个一个传进来的children
            children = Array.prototype.slice.call(arguments,2)
        }else if(l ===3 && isVNode(children)){
            children = [children]
        }
        return createVNode(type,propsOrChildren,children)
    }
}
```

然后其中我们使用createVNode来创建

```js
//创建VNode前先指定类型
export function createVNode(type,props,children?):VNode{
    //一连串三元表达式判断是什么类型
    const shapeFlag = isString(type)?ShapeFlags.ELEMENT
                      :isObject(type)?ShapeFlags.STATEFUL_COMPONENT:0

    if (props) {
		// 处理 class
		let { class: klass, style } = props
		if (klass && !isString(klass)) {
			props.class = normalizeClass(klass)
		}
	}

    return creatBaseVNode(type,props,children,shapeFlag)
}
```

这里我们使用了一个ShapeFlags，是定义好的一个emun类型存了一些数字，其实就是作为指令，用来render的时候识别用。

![1679309136024](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679309136024.png)

其中我们处理了一下class（强化class），就是这样可以让class以对象形式传，它自动改成字符串

然后我们使用creatBaseVNode创建VNode

```js
//创建VNode对象
function creatBaseVNode(type,props,children,shapeFlag){
    const vnode = {
        __v_isVNode:true,
        type,
        props,
        shapeFlag
    }as VNode

    //解析children，然后给父vnode搞完善
    normalizeChileren(vnode,children)

    return vnode
}

```

当然，我们需要对children进一步处理

```js
//将children标准化搞成Vnode的函数
export function normalizeChileren(vnode:VNode,children:unknown){
    //根据状态解析
    let type = 0
    const { shapeFlag } = vnode
    if(children == null){
        //1.如果children是 空
    }else if(Array.isArray(children)){
        //2.如果children是 Array
        type = ShapeFlags.ARRAY_CHILDREN

    }else if(isObject(children)){
        //3.如果children是 对象

    }else if(isFuntion(children)){
        //4.如果children是 函数

    }else{
        //5.如果children是 字符串
        //转一下,现在有了children的type
        children = String(children)
        type = ShapeFlags.TEXT_CHILDREN
    }

    vnode.children = children
    vnode.shapeFlag |= type
}
```

最终根据这个父子的结果，我们生成了shapeFlag供render使用

这样初步完成了h函数

### 总结一下

我们舍弃了很多边缘情况

就搞了一下几种

父亲情况：

1.父element

2.父componet

子：

1.子字符串

2.子数组

3.子空

例子：

```js
//父ele子数组：
const vnode = h('div',{class:'test'},[h('p','p1'),h('p','p2'),h('p','p3')])
//父componet子空
const componet = {
      render(){
      const vnode1 = h('div','这是一个组件')
      return vnode1
      }
}
const vnode2 = h(componet)
```

当然还有三种情况：Text、Comment、Fragement

其实就是字符串，处理了一点变化，最后需要在render识别的时候单独渲染处理一下

![1679309930438](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679309930438.png)

## render

### 整体流程4步

0.执行patch方法，根据type和shapeFlag决定当前执行哪种类型挂载，根据旧节点是否存在决定更新还是创建

1.生成当前div标签

![1679315667669](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679315667669.png)

2.生成里面的text

![1679315687355](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679315687355.png)

3.处理props

![1679315730289](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679315730289.png)

4.插入页面

![1679315745792](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679315745792.png)

最后指定旧节点

**指南**：

![1679316105754](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679316105754.png)

### *render整体框架

首先看render.ts

```js
import { ShapeFlags } from "packages/shared/src/shapeFlag"
import { Text,Comment, Fragment } from "./VNode"

//兼容性的方法集合
export interface RenderOptions{
    //为指定el打补丁
    patchProp(el:Element,key:string,preValue:any,nextValue:any):void
    //为指定el这只text
    setElementText(el:Element,text:string):void
    //插入元素，anchor是锚点，插谁前面
    insert(el,parent:Element,anchor?)
    //创建el
    creatElement(type:string)
}

//入口
export function createRender(options:RenderOptions){
    return baseCreatRenderer(options)
}

export function baseCreatRenderer(options:RenderOptions):any{
    //具体更新操作
    const patch = (oldVNode,newVNode,container,anchor=null)=>{
        if(oldVNode === newVNode){
            return
        }
        const {type,shapeFlag} = newVNode 
        //通过不同的类型选择不同的更新方式
        switch(type){
            case Text:
                break
            case Comment:
                break
            case Fragment:
                break
            default:
                //还有两种情况，组件和element
                if(shapeFlag&ShapeFlags.ELEMENT){
                    //TODO
                }else if(shapeFlag&ShapeFlags.COMPONENT){
                    //TODO
                }
        }
    }

    //渲染总函数
    const render = (vnode,container) => {
        if(vnode === null){
            //TODO卸载
        }else{
            //更新DOM
            patch(container._vnode||null,vnode,container)
        }
    }

    return{
        render

    }
}

```

然后再runtime-dom中，我们封装了一些dom操作函数方便后面编写使用

![1679319099881](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679319099881.png)

然后还有处理参数的函数

![1679319137738](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679319137738.png)

其中处理class的函数，我们写在了modeul中

![1679319192456](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679319192456.png)

class是这样处理的，后面还会有style等...

![1679319242393](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679319242393.png)

### *render基本实现逻辑

上文中我们看了，baseCreatRenderer返回的是包含render的对象，也就是说我们**使用render时候导出需要导出**baseCreatRenderer的返回值，我们这么导：

![1679476837438](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679476837438.png)

然后我们**进render看看**（都是写在baseCreatRender里的）

![1679476923365](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679476923365.png)

可以看到几个重要的点

1.新节点为空，旧节点存在，删除！

2.为container添加一个新属性_vnode存储了旧节点

3.patch执行了具体的操作

下面看一**下patch做什么了**

![1679477080369](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679477080369.png)

**分情况讨论，主要先看一下处理Element**

![1679477216738](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679477216738.png)

如果old是空，则执行挂载操作，否则就更新

**先看挂载怎么做的**

![1679477270508](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679477270508.png)

分为四步：

1.创建，是基于document.createElement

![1679477592425](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679477592425.png)

2.确定之后先修改内部的字符串孩子内容

![1679478057702](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478057702.png)

3.设置props

因为不同的属性有不同的添加方法，我们需要分情况讨论

![1679478180711](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478180711.png)

然后具体的方法就在modules中了

![1679478217756](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478217756.png)

其中事件需要单独提一下，整了一个invokers，缓存事件和回调，这样事件不变，回调变得话只要改invoker的value就行了，省去了操作DOM添加事件监听，浪费时间。

![1679478344905](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478344905.png)

4.最后插入container

![1679478405664](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478405664.png)

**然后是Element的更新操作**

![1679478527321](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478527321.png)

其中，先**更新孩子**

![1679478615103](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478615103.png)

到目前为止，只是实现了1.5个情况

1.新子节点为text，就子节点也是

2.新节点不为text，子节点是text（还没完成）

再**更新参数**，利用上文提到的那个更新参数的方法逐个更新

![1679478765166](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478765166.png)

其他的还有一些其他节点的操作

比如**TEXT**

![1679478906623](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478906623.png)

![1679478925800](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478925800.png)

比如comment(注释)

![1679478951507](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478951507.png)

![1679478975435](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679478975435.png)

比如fragment，这个是只渲染子节点，不渲染自己

![1679479016418](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679479016418.png)

![1679479035215](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679479035215.png)

**其实个人觉得可以再补全，比如初次挂载的时候可以修改一下这个mountChilren函数，实现数组孩子的挂载**

**那这样就要改一下normalizeVNode了**

![1679479158184](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679479158184.png)

**就不应该是creatTEXT类型的了，应该递归一下。**



## render挂载组件

### *无状态组件挂在逻辑

无状态组件指的是没有数据的组件挂载

首先，我们在patch中进入组件的打补丁操作

![1679489023275](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679489023275.png)

然后，第一次需要挂载，也就是old==null的时候

![1679489096305](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679489096305.png)

然后挂载

![1679489128614](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679489128614.png)

不仅挂载了，而且生成了effect执行了，effect是异步，effect中的就是更新渲染操作。

有个小细节，initialVNode.el = subTree.el很关键

首先明确一下initialVNode是type为组件对象的vnode

subTree是组件对象里render属性返回值的vnode

最终渲染的时候渲染的是render属性返回值的vnode也就是vnode

但是，我们在patch中进行对比的时候对比的是initialVNode

这很重要

这影响到了更新操作

再看更新操作的逻辑

![1679489374503](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679489374503.png)

假如由此代码，在执行计时器时，首先来到了patch

因为组件不同，所以type不同，所以会直接卸载

![1679489452395](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679489452395.png)

但是其中逻辑是传入node.el，再利用如下DOM操作删除

![1679489495505](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679489495505.png)

但是如果没有上面很重要的那个代码，这个oldVNode是没有el的

但是oldVNode.component.subTree.el是存在的

好好理解，出了bug了，改了好久

当然以上是无状态，不涉及响应式

### *有状态的组件

这就是有状态的组件：

![1679491773547](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679491773547.png)

其中区别在于多了一个data，其实就是vue3的optionAPI

然后我们需要处理这些option，再setComponent中，在上一节无状态组件中，这个函数的主要作用是给render赋值给instance

现在又多了一项使命

![1679491921235](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679491921235.png)

我们现在拿到的instance中有data了，我们还需要在创建subTree的时候拿到它，可以看到定义组件时都是用的this，所以我们需要执行instance.render时候使用call改变this指向才能拿到带有准确值得vnode

![1679492047980](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679492047980.png)

个人：此处触发了get

其他：未来肯定陆续添加更多option

### *生命周期

![1679495156549](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495156549.png)

首先先整四个生命周期

beforecreate和created都可以在处理option时直接触发

![1679495213072](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495213072.png)

但是其他的生命周期不可以在这里直接触发，需要到其他地方，比如挂载的地方

我们可以对其注册，注册到instance上，这样就方便多了

首先看一下简写

![1679495296347](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495296347.png)

注册

![1679495317485](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495317485.png)

![1679495344216](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495344216.png)

然后我们用的时候直接在render.js用就好了

![1679495424133](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495424133.png)

然后我们看一下效果

![1679495464869](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679495464869.png)

### *生命周期函数访问data(改变this指向)

![1679535261630](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679535261630.png)

### *修改组件内数据重新渲染

这里的更新跟上边的更新不一样，上边的更新指的是换了个组件，这次是内容变了

因为会触发依赖

其中componentUpdateFn已经作为effect绑定到了相关响应式属性中

所以我们只需要修改componentUpdateFn

![1679536458947](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679536458947.png)

### *setup

先看用法

![1679543812847](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679543812847.png)

其实更简单了

只用看一下instance有没有setup这个属性，来判断是不是组合api写法就好了

![1679543874874](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679543874874.png)

还挺重要的！深刻理解setup

optionAPI需要改变this指向，组合API不用

## diff

### 引言

diff是更新时的对比操作

如果两个子节点都是array，需要进行对比

![1679552827080](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679552827080.png)

分为五种情况

[就看这个，讲得忒好了](https://blog.csdn.net/zl_Alien/article/details/106595459?ops_request_misc=&request_id=&biz_id=102&utm_term=diff%E7%AE%97%E6%B3%95%20vue3%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-106595459.142^v76^control_1,201^v4^add_ask,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)

### *前四个情况【easy】

![1679571933315](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679571933315.png)



![1679571950603](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679571950603.png)

### *情况五【好好理解还不太会】

看这个

[就看这个，讲得忒好了](https://blog.csdn.net/zl_Alien/article/details/106595459?ops_request_misc=&request_id=&biz_id=102&utm_term=diff%E7%AE%97%E6%B3%95%20vue3%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-106595459.142^v76^control_1,201^v4^add_ask,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)

效果：

![1679573776389](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679573776389.png)



![1679573819441](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679573819441.png)

![1679573841895](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679573841895.png)

### 渲染原理图和diff回答废话模板

![1679569656298](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679569656298.png)

![1679570261197](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679570261197.png)

## 编译时编辑器基础知识



### 编译流程

**![1679574961298](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679574961298.png)**

codegenNode

![1679576013220](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679576013220.png)

### 有限状态机

![1679577782067](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679577782067.png)

解释例子：

![1679577955529](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679577955529.png)

  ![1679578238231](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679578238231.png)

### 模板解析

![1679579181719](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679579181719.png)

![1679579207177](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679579207177.png)

![1679619463870](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679619463870.png)

## 模板编译

### *整体框架

![1679619823858](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679619823858.png)

![1679621154846](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679621154846.png)

然后到baseCompile

![1679621206904](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679621206904.png)

然后再到baseParse生成ast

![1679621234379](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679621234379.png)

用法：

![1679621513838](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679621513838.png)

![1679621528867](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679621528867.png)

### *解析生成AST

![1679664063815](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679664063815.png)

此时context中的source存的是需要渲染的字符串

然后我们baseParse，相当于从现在开始渲染根节点的孩子，所以整体过程从parseChildren开始

![1679664235000](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679664235000.png)

解析element

![1679664500368](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679664500368.png)

其中涉及到处理孩子，假如孩子是纯文本节点，到了parseChildren中，还是要到parseText

![1679664573904](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679664573904.png)

测试一下

​    const { h,render,reactive,compile } = MiniVue

​    const template = `<div>hello world</div>`

​    const renderFn = compile(template)

返回什么东西：

![1679664649117](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679664649117.png)



借助这些信息转JSast



### *AST转JSAST整体流程

1.转化策略：对象结构变化，方便生成render函数

2.深度优先

3.转化函数分离Text、Element等

 ![1679663937164](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679663937164.png)

在basecompile这里进行了调用

![1679667553652](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679667553652.png)

首先我们再编译core新建transform.ts

![1679667577047](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679667577047.png)

其中，createTransformContext创建上下文对象：

![1679667616748](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679667616748.png)

然后们就可以进行tranverseNode操作了

![1679667693189](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679667693189.png)

为什么说利用了递归，因为tranverseChildren调用了tranverseNode

![1679667725034](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679667725034.png)

当然其中transformElement,transformText是具体的转化不同类型节点的操作

被定义在编译核心的transform文件夹下，后面将具体介绍

### *transform具体操作

上文提到了整体框架，下面就到了transformElement,transformText

首先transformElement

![1679708674294](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679708674294.png)

核心作用就是增加了codegenNode属性，可以看到，最后修改的是原来的ast的node，完成转化

再看transformText

```js
//转Text
//核心作用：将相邻的文本节点和表达式节点合并为一个表达式
/**
 * 例如:
 * <div>hello {{ msg }}</div>
 * 上述模板包含两个节点：
 * 1. hello：TEXT 文本节点
 * 2. {{ msg }}：INTERPOLATION 表达式节点
 * 这两个节点在生成 render 函数时，需要被合并： 'hello' + _toDisplayString(_ctx.msg)
 * 那么在合并时就要多出来这个 + 加号。
 * 例如：
 * children:[
 * 	{ TEXT 文本节点 },
 *  " + ",
 *  { INTERPOLATION 表达式节点 }
 * ]
 */
```

![1679708778540](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679708778540.png)

然后最后，我们需要生成需要的jsast的格式，那就把需要的属性都给加上

![1679708872342](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679708872342.png)

其中创建根节点只实现了一种情况，就是只有一个dom节点的时候

![1679708907587](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679708907587.png)

然后我们测试生成了一下转化完成的ast

​    const template = `<div>hello world</div>`

​    const renderFn = compile(template)

![1679709012776](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679709012776.png)

测试一下这个东西可以被generate成render函数吗

当然，这得用源码里的测试，我的minivue还没写呐

【测试不了，看后边吧】

### *render函数生成方案(字符串拼接)

主要是靠字符串的拼接

```js
import { isString } from "@vue/shared"
import { NodeTypes } from "./ast"
import { helperNameMap } from "./runtimeHelpers"
import { getVNodeHelper } from "./utils"

//拼接个结构赋值里面的那个字符串：createVNode:_createVNode
const aliasHelper = (s:symbol) => `${helperNameMap[s]}:_${helperNameMap[s]}`

//genetate上下文对象
function createCodegenContext(ast){
    const context = {
        code:'', //拼接的函数字符串
        runtimeGlobalName:'MiniVue',
        source:ast.loc.source,
        indentLevel:0,//缩进
        isSSR:false,
        helper(key){
            return `_${helperNameMap[key]}`
        },
        push(code){
            context.code += code
            //拼接render函数字符串
        },
        newline(){
            newline(context.indentLevel)
            //换行
        },
        indent(){
            newline(++context.indentLevel)
            //进
        },
        deindent(){
            newline(--context.indentLevel)
            //缩
        }
    }
    return context
    
function newline(n:number){
    context.code += '\n'+``.repeat(n)
}
}



//jsast生成render函数并返回
export function generate(ast){
    const context = createCodegenContext(ast)
    const {push,newline,indent,deindent} = context
    //开始拼接
    //首先是前置代码
    getFunctiopnPreamble(context)

    //函数头：function render(_ctx,_cache)
    const functionName = `render`
    const args = ['_ctx','_cache']
    const signature = args.join(',')
    push(`function ${functionName}(${signature}){`)
    indent()

    //第一行：const { createElementVNode: _createElementVNode } = _Vue
    const hasHelps = ast.helpers.length>0
    if(hasHelps){
        push(`const { ${ast.helpers.map(aliasHelper).join(',')} } = _Vue`)
        push('\n')
        newline()
    }

    //第二行节点：return _createElementVNode("div"，[]，["hello word"])
    newline()
    push(`return `)
    if(ast.codegenNode){
        genNode(ast.codegenNode,context)
    }else{
        push(` null`)
    }

    //最后的大括号
    deindent()
    push('}')

    return{
        ast,
        code:context.code
    }
}

//处理节点的那行代码生成：return _createElementVNode("div"，[]，["hello word"]) 
function genNode(node,context){
    switch(node.type){
        case NodeTypes.VNODE_CALL:
            genVNodeCall(node,context)
            break
        case NodeTypes.TEXT:
            //如果是纯文本节点直接返回
            genText(node,context)
            break
    }
}
//如果是纯文本节点
function genText(node,context){
    context.push(JSON.stringify(node.content))
}
//创建节点的函数
function genVNodeCall(node,context){
    //_createElementVNode(
    const { push,helper } = context
    const { tag,props,children,patchFlag,dynamicProps,directives,isBlock,disableTracking,isComponent } = node
    //获取使用的函数是CREATE_VNODE还是CREATE_ELEMENT_VNODE
    const callHelper = getVNodeHelper(context.isSSR,isComponent)
    push(helper(callHelper)+`(`)
    //参数"div"，[]，["hello word"]
    const args = genNullableArgs([tag,props,children,patchFlag,dynamicProps])
    genNodeList(args, context)
    push(')')
}

//处理一下参数"div"，[]，["hello word"],去null
function genNullableArgs(args:any[]){
    let i = args.length
    //整理出有效的参数 
    while(i--){
        if(args[i]!=null)break
    }
    return args.slice(0,i+1).map(arg=>arg||`null`)
}
//处理一下参数"div"，[]，["hello word"]
function genNodeList(nodes,context){
    const { push,newline } = context
    for(let i = 0;i<nodes.length;i++){
        const node = nodes[i]
        if(isString(node)){
            push(node)
        }else if(Array.isArray(node)){
            genNodeListAsArray(node,context)
        }else{
            genNode(node,context) //对象：递归处理
        }
        if(i<nodes.length-1){
            push(',') //参数之间逗号分割
        }
    }
}

//处理数组参数
function genNodeListAsArray(nodes,context){
    context.push('[')
    genNodeList(nodes,context) //递归处理 
    context.push(']')
    
}


 //前置代码：const _Vue = MiniVue
function getFunctiopnPreamble(context){
    const {push,runtimeGlobalName,newline} = context
    const VueBinding = runtimeGlobalName
    push(`const _Vue = ${VueBinding}`)
    newline()
    push(`return `)
}
```

直接上来看吧，最后拼接出来是这个样子

![1679882538918](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679882538918.png)

这样一个字符串，看我们是怎么用的

![1679882578403](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679882578403.png)

然后我们可以让compile直接返回函数，而不是字符串

我们可以封装一下

先整个函数

![1679883094766](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679883094766.png)

然后我们再在vue index.ts中改变一下导入路径

![1679883149801](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679883149801.png)

于是用法变简单了

![1679883231370](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679883231370.png)

## 深入编辑器

### *实现插值语法

![1679888185208](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679888185208.png)

在这里我好好整理一下这些逻辑

这一步的需求是需要当有插值语法时，我们也能成功渲染

![1679907220210](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679907220210.png)

**第一步**，我们需要再解析的时候做出一些改变

![1679907276645](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679907276645.png)

当遇到大括号时，代表遇到了插值表达式类型，那么去处理，返回一个node

![1679907420852](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679907420852.png)

然后这样我们就完成了解析ast的步骤

**第二步**，我们需要完成转化JSast的处理，其中主要区别时我们需要给helpers添加一个tostring方法

![1679907785883](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679907785883.png)

当然，这要求我们先把TO_DISPLAY_STRING声明好

![1679907851226](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679907851226.png)

这个函数定义在shared并在vue中导出，同时compile也是在vue中导入包装再导出，所以可以直接访问到。其实这个函数就是一个返回字符串的函数。

![1679908055984](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679908055984.png)

**另外值得一提的是**，如果有两个孩子节点，都是Text(插值语法节点也被视作Text节点)比如：hello{{msg}}

在转化的时候，会自动添加+号，并合成一个CompoundExpression格式

![1679909302059](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679909302059.png)

**第三步**，我们需要处理一下生成render函数的部分

![1679909399021](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679909399021.png)

先捋一下

CompoundExpression的content：["hello"+msg(Expression)]

Expression的content：msg

Interpolation的content：msg(Expression)

这样就理解了，下面先看这三个函数:

![1679909680375](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679909680375.png)

还有一个小点需要说明一下，其中这个和with(_ctx)是用来改变this指向的

所以我们在生成组件，给它传入render函数的时候顺便把data当参数传进去。

<img src="C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679916515681.png" alt="1679916515681 " style="zoom:50%;" />

![1679910656565](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679910656565.png)

最后看看生成的啥样

![1679909733222](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679909733222.png)

这就是render函数

### *多层级模板编译

![1679916777608](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679916777608.png)

多层级还不行

![1679917123328](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679917123328.png)

### *指令-生成ast

首先是处理指令的逻辑

模板中我么写好了指令，然后我们先生成包含指令的ast

ast中，指令和普通的属性都在props中，然后v-if会被搞成name为if的节点

在解析节点是，有parseTag

![1679925108355](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679925108355.png)

然后解析，循环解析

![1679925143641](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679925143641.png)

具体解析单个节点过程如下

![1679925247954](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679925247954.png)

然后其中获取指令名的操作

![1679925315177](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679925315177.png)

### *指令-转化JSast

原理是这样的，原本我们的代码中，tranverseNode中有这样的一段

![1679966762496](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679966762496.png)

那么，应该在transformElement中对参数有所处理

![1679967114376](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679967114376.png)

那原理是这样的，上边循环三个函数转化为onExit，加入exitFns等待执行，那看一下

![1679967898463](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679967898463.png)

createStructuralDirectiveTransform这个函数定义在transform.ts中了，其实他是复用的，什么指令都能用

![1679968307321](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679968307321.png)

上上张图的大红框就是上图的fn

下面看处理if的操作，其实就是创建了一个新节点替换原来的

![1679968643029](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679968643029.png)

其中processIf的第四个参数是个函数，其实就是处理ifNode，为它添加codegenNode

在transformIf中，如果没有，我们先createCodegenNodeForBranch

![1679968837062](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679968837062.png)

其中还有if被定位false后用一个注释节点来替换。

还包含了一堆节点的建立，比如createConditionalExpression返回是个type为NodeTypes.JS_ARRAY_EXPRESSION的节点

可以看到，上图判断了branch.condition，这个东西是啥，建branch的时候：

![1679969289854](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679969289854.png)

这个东西ast中就有，其实就是：

![1679969340382](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679969340382.png)

有这个东西，证明了是v-指令

ok，言归正传，继续说，刚才判断了是不是v节点，然后是的话创建了一个JS_ARRAY_EXPRESSION的节点

其中都要creatChildrenCodegenNode

![1679969662156](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679969662156.png)

其中涉及很多建立对象的函数，都是建立了不同type的节点对象，包括：

JS_PROPERTY、JS_CACHE_EXPRESSION、JS_OBJECT_EXPRESSION、IF_BRANCH、IF等。

最后在tranverseNode函数中添加一下两种节点：

![1679970182143](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679970182143.png)

**整体逻辑总结**【debug看看jsast长啥样就行了】

整体逻辑就是创建branches【理解为一种子节点】，然后transform中给节点添加codegenNode

![1679970342472](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679970342472.png)

### *指令-生成render

先看最终生成的render

![1679970537843](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679970537843.png)

### *一次debug的纪念碑

#### 1

这次出现了好几个问题，总的来说，就是莫名奇妙没有了codegenNode，然后我一步一步找过来，发现是很多NodeTypes写错了，导致后面没有办法执行，而且有一个问题是createRootCodegen没有办法创建根节点，因为有一个判断：

![1679995355827](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679995355827.png)

![1679995369164](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679995369164.png)

我添加了这个if，才能创建根节点的NodeType，前边也说了，可以把IF看作一个element Node。

#### 2

然后我又出现了一个问题，因为之前我把patch改成了patchChildren，因为在插值语法的时候，hello{{msg}}会编程’hello‘+msg也就是helloword

![1679999350784](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679999350784.png)

最重要的是它的shapflag是TEXT_CHILDREN，这很难办，因为原来的patch不能处理这个

![1679999569502](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679999569502.png)

**那咋办，其实这种处理就和Text一模一样。**

可是之前没想到，就直接把patch换成了patchChildren

这导致后边一个问题

![1679999662033](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679999662033.png)

这样嵌套的模板我是渲染不出来的

因为patchChildren没有处理Element方法的，主要是处理TEXT_CHILDREN和ARRAY_CHILDREN，所以渲染不出来。

另一个例子也是

![1679999848797](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679999848797.png)

这种情况会只渲染一次，不停地给节点更新，因为挂载的时候，是写的这行代码：

![1679999900319](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679999900319.png)

所以如果使用的是patchChildren：

![1679999999537](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1679999999537.png)

也就是d

md，这可咋办，其实很简单，还是继续用patch

加个操作就行了

![1680000059127](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680000059127.png)

#### 最后

这次debug其实发现的问题都是小问题

1.写代码细心，检查关键值和不同情况又没有覆盖

2.注意检查函数返回值

![1680000223108](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680000259277.png)

![1680000269663](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680000269663.png)

成功了

![1680000848292](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680000848292.png)

响应式也可以了

## CreateApp和template

### CreateApp

封装一下api

![1680007362842](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007362842.png)

这个东西在render中跟render一起返回

![1680007401791](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007401791.png)

然后看看是怎么暴漏的

![1680007447124](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007447124.png)

使用就行了：

![1680007471986](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007471986.png)

![1680007489525](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007489525.png)

### template

上一个案例用到了template

其实很简单，把compile传到runtime里，构建的时候顺便生成render就行

![1680007613902](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007613902.png)

这个compile需要传过来哦

![1680007693809](C:\Users\qwer\AppData\Roaming\Typora\typora-user-images\1680007693809.png)

## over